var documenterSearchIndex = {"docs":
[{"location":"man/types/#Public-types","page":"Public types","title":"Public types","text":"","category":"section"},{"location":"man/types/#Public-types-in-module-VisAna:","page":"Public types","title":"Public types in module VisAna:","text":"","category":"section"},{"location":"man/types/","page":"Public types","title":"Public types","text":"Modules = [VisAna]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"man/testparticle/#Test-Particle-Simulation","page":"Test Particle Simulation","title":"Test Particle Simulation","text":"","category":"section"},{"location":"man/testparticle/","page":"Test Particle Simulation","title":"Test Particle Simulation","text":"(Image: ion_trajectory_dipole)","category":"page"},{"location":"man/testparticle/","page":"Test Particle Simulation","title":"Test Particle Simulation","text":"This part needs many more improvements!","category":"page"},{"location":"man/text/#Text-Data-Processing","page":"Text Data Processing","title":"Text Data Processing","text":"","category":"section"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"Now it is an age of big data. The fundamental of big data is how to process data efficiently. This section is about text data processing, including data organization, regular expression, and web scraping.","category":"page"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"Examples can be found in the timing folder.","category":"page"},{"location":"man/text/#Data-Format","page":"Text Data Processing","title":"Data Format","text":"","category":"section"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"There are two basic packages for reading/writing ascii data:","category":"page"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"DelimitedFiles\nCSV","category":"page"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"The first one is a built-in package for handling relatively simple data, while the second one is for handling complicated data with seamless support for DataFrame.","category":"page"},{"location":"man/text/#Regular-Expression","page":"Text Data Processing","title":"Regular Expression","text":"","category":"section"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"Julia has built-in support for regular expressions. The best reference and tool I have ever used for regular expression in general is RegExr.","category":"page"},{"location":"man/text/#Web-Scraping","page":"Text Data Processing","title":"Web Scraping","text":"","category":"section"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"Packages worth mentioning:","category":"page"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"HTTP\nGumbo\nCascadia","category":"page"},{"location":"man/analysis/#Data-Analysis-in-Space-Physics","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"","category":"section"},{"location":"man/analysis/#Diffusion-Region-Detection","page":"Data Analysis in Space Physics","title":"Diffusion Region Detection","text":"","category":"section"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Magnetic reconnection occurs in a small diffusion region around the X-line but its consequences are large scale. There are different approaches to determine whether or not we have encountered the diffusion region. The expected kinetic signatures of diffusion region:","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"enhanced dissipation\nnon-gyrotropic behavior\nelectron distribution functions","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The first proposed non-gyrotropy measure by Jack Scudder and William Daughton is","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"AØ_e = 2fracP_perp1 - P_perp2P_perp1 + P_perp2","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"which only considers the non-gyrotropy in the plane perpendicular to the magnetic field.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Another measure of non-gyrotropy D_ng of a specific population proposed by researchers can be think of a ratio between off-diagonal terms and diagonal terms of the pressure tensor:","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"D_ng = frac2sqrtsum_ij ineq jP_ij^2sum_i=13P_ii^2","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Note that this is frame independent and population specific.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"However, Marc Swisdak later demonstrated in his paper that a better measure from positive semi-definite matrix analysis should be","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Q = fracP_12^2 + P_23^2 + P_31^2P_perp^2 + 2P_perp P_parallel = 1- 4fracI_2(I_1 - P_parallel)(I_1 + 3P_parallel)","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"where I_1=P_xx+P_yy+P_zz is the trace and I_2=P_xxP_yy+P_xxP_zz+P_yyP_zz-(P_xyP_yx+P_xzP_zx+P_yzP_zy) is the principle minor, both of which are invariants under coordinate rotation. (The third invariant is the determinant.) This indeed peak near the center of X-line while is enhanced along the separatrices, which is better than D_ng in the sense that the latter may not peak at the diffusion region.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"It has been found from PIC simulations that especially in asymmetric reconnection, E_M^astneq 0 where mathbfE^ast=mathbfE+mathbfV_etimesmathbfB is not a good enough indicator. Following the principle ideas of finding a measure:","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"dissipation should be related to non-ideal energy conversion;\nscalar indicator;\ninsensitive to the relative motion,","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"a frame independent dissipation measure is constructed,","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"D_e = gamma_ebigmathbfJcdot(mathbfE+mathbfV_etimesmathbfB) - (n_i - n_e)(mathbfV_etimesmathbfE)big","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"which is a Lorentz-invariant scalar representing the energy conversion rate in the frame of electron bulk motion. In the nonrelativistic limit, one can simplify the equation by setting gamma_erightarrow 1. This can be easily confirmed by multiplying mathbfj^prime=qn_imathbfV_i=mathbfj-rho_cmathbfV_e and mathbfE^prime = mathbfE+mathbfVtimesmathbfB.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"This is another good indicator of the electron diffusion region, although it is slightly enhanced along the separatrices as well.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"An alternative and complementary approach is to identify diffusion region candidates by a combination of representative properties. In practice for reconnection with no guide field for instance, the overlapped region of B_L=0 and E_N peak, where some researchers call 'shoulder', is already good enough for the identification.","category":"page"},{"location":"man/analysis/#Spectral-Analysis","page":"Data Analysis in Space Physics","title":"Spectral Analysis","text":"","category":"section"},{"location":"man/analysis/#FFT","page":"Data Analysis in Space Physics","title":"FFT","text":"","category":"section"},{"location":"man/analysis/#Periodogram","page":"Data Analysis in Space Physics","title":"Periodogram","text":"","category":"section"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"This is a group of techniques to determine the periodicity of data. Essentially it is the same as Fourier transform, but with the inverse of frequency as the x axis. Julia has implementations in the DSP package. Here we introduce the usage by looking at practical examples.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"note: Note\nBe careful of any smoothing you apply to the raw data. It is very easy to forget about the tricks you use in analyzing raw data and come up with a biased conclusion.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"A Savitzky-Golay filter can be used to smooth data before applying any further analysis. The idea is to use local polynomial approximations to replace the original data.","category":"page"},{"location":"man/analysis/#Spectrogram","page":"Data Analysis in Space Physics","title":"Spectrogram","text":"","category":"section"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Spectrogram is used a lot in wave analysis. For my purpose, I use it as an approach to visualize time dependent simulation data along a continuous line region.","category":"page"},{"location":"man/analysis/#Minimum-Variance-Analysis","page":"Data Analysis in Space Physics","title":"Minimum Variance Analysis","text":"","category":"section"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"A nice introduction is given by Bengt U.Ö.Sonnerup and Maureen Scheible.  Here is a brief summary of the idea. The implementation of MVA can be found in  MVA.jl.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The main purpose of minimum or maximum variance analysis (MVA) is to find, from single-spacecraft data, an estimator for the direction normal to a one-dimensional or approximately one-dimensional current layer, wave front, or other transition layer in a plasma.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"For real transition layers observed in space there are usually more or less pronounced deviations from the ideal 1-D model. The layer is likely to have 2-D or 3-D internal structures which evolve in time and to have temporal fluctuations in the orientation of its normal as well.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The minimum variance technique is designed to deal with the situation where some or all of the non-ideal effects mentioned above, except a systematic temporal change in the normal direction, widehatn, are present. As the estimate of  widehatn, the method identifies that direction in space along which the field-component set {mathbfB^(m)cdotwidehatn} (m = 1 2 3M)  has minimum variance. In other words, widehatn is determined by  minimisation of","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"sigma^2 = frac1M sum_m=1^M (mathbfB^(m) - mathbfB)cdotwidehatn ^2","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"where the average langlemathbfBrangle is defined by","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"langlemathbfBrangle equiv frac1M sum_m=1^M mathbfB^(m)","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"and where the minimisation is subject to the normalisation constraint widehatn=1. Using a Lagrange multiplier lambda to implement this constraint, one then seeks the solution of the set of three homogeneous linear equations","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"fracpartialpartial n_xBig( sigma^2 - lambda (widehatn^2 - 1) Big) = 0 \nfracpartialpartial n_yBig( sigma^2 - lambda (widehatn^2 - 1) Big) = 0 \nfracpartialpartial n_zBig( sigma^2 - lambda (widehatn^2 - 1) Big) = 0","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"where sigma^2 is given by the equation above and widehatn is represented in terms of its three components (n_x n_y n_z) along the cartesian coordinate system X, Y, Z (e.g., GSE or GSM) in which the field data mathbfB^(m)  are given. When the differentiations in equations above have been performed, the resulting set of three equations can be written in matrix form as","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"sum_nu=1^3 M_munu^B n_nu = lambda n_mu","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"where the subscripts munu = 123 denote cartesian components along the X, Y, Z system and","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"M_munu^B equiv langle B_mu B_nurangle - langle B_muranglelangle B_nurangle","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"is the magnetic variance matrix. It is seen from the equation that the allowed lambda values are the eigenvalues lambda_1lambda_2lambda_3 (given here in order of decreasing magnitude) of M_munu^B. Since M_munu^B is symmetric, the eigenvalues are all real and the corresponding eigenvectors, x_1, x_2, and x_3, are orthogonal. The three eigenvectors represent the directions of maximum, intermediate, and minimum variance of the field component along each vector.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"note: Note\nIn practice, the ratio of intermediate to minimum variance should be larger than 5 to give good fit of LMN.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"A not so good example case is the Galileo G8 Ganymede flyby magnetometer data: (Image: ) where the ratio between the intermediate and minimum eigenvalue is only about 2.","category":"page"},{"location":"man/analysis/#ULF-Wave-Detection","page":"Data Analysis in Space Physics","title":"ULF Wave Detection","text":"","category":"section"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"ULF waves are MHD waves: Alfvén wave, fast wave and slow wave. One basic approach to identify waves is to check the correlation of quantity perturbations.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The phase speed of shear Alfvén wave is","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"v_pA = fracomegak = v_A costheta","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"where v_A is the Alfvén speed and theta is the angle between wave vector mathbfk and magnetic field mathbfB.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The perturbed quantities of Alfvén waves follow these relations:","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"fracdelta mathbfvv_A = pm fracdelta mathbfBB_0 \ndelta rho = 0","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"where delta mathbfv, delta mathbfB, and delta rho are perturbed plasma velocity, magnetic fields, and plasma density, respectively, and B_0 is the background magnetic magnitude.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"For slow and fast waves, the phase speeds are","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"v_ppm^2 = big(fracomegak big) = frac12(v_s^2 + v_A^2) pm frac12Big (v_s^2 + v_A^2)^2 - 4v_s^2 v_A^2 cos^2thetaBig^12","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The \"+\" is for fast waves and \"−\" for slow waves, and v_S is the sound speed. The perturbed quantities for fast and slow waves are","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"delta rho = fracrho_0v_pfracv_A^2sinthetaB_0 (v_p - v_s^2v_p)delta B\ndelta mathbfv = -fracv_A^2 costhetaB_0 v_pdeltamathbfB + fracv_A^2 sinthetadelta BB_0 (v_p - v_s^2v_p)fracmathbfkk","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Thus generally the Alfvén wave is identified by the correlations between velocity and magnetic field perturbations, and the fast and slow waves are identified by the negative (for slow waves) or positive (for fast waves) correlations between either density and magnetic field perturbation or thermal pressure and magnetic pressure perturbation.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The second equation above can also be expressed in terms of magnetic and thermal pressure pertubations:","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"delta P_B = fracmathbfB_0 cdot mathbfBmu_0\n=fracV_A^2V_S^2left(1-frack^2 V_S^2 cos^2thetaomega^2right)delta P_t","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"See the lecture notes for more details.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"For the magnetosonic waves, consider using delta mathbfE and delta mathbfB for identifying speed. The slopes of the curves delta Edelta B correspond to the wave propagation speed in the spacecraft frame.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Transverse and shear Alfvén wave refer to actually the same thing: the descriptions arise from  mathbfkcdotmathbfV=0 and mathbfVcdotmathbfB_0=0.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The fast and slow magnetosonic waves are associated with non-zero perturbations in the plasma density and pressure, and also involve plasma motion parallel, as well as perpendicular, to the magnetic field. The latter observation suggests that the dispersion relations omega=kV_pm are likely to undergo significant modification in collisionless plasmas. In order to better understand the nature of the fast and slow waves, let us consider the cold-plasma limit, which is obtained by letting the sound speed V_S tend to zero. In this limit, the slow wave ceases to exist (in fact, its phase velocity tends to zero) whereas the dispersion relation for the fast wave reduces to","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"omega = kV_A","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"This can be identified as the dispersion relation for the compressional-Alfvén wave. Thus, we can identify the fast wave as the compressional-Alfvén wave modified by a non-zero plasma pressure.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"In the limit V_Agg V_S, which is appropriate to low-beta plasmas, the dispersion relation for the slow wave reduces to","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"omega simeq kV_Scostheta","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"This is actually the dispersion relation of a sound wave propagating along magnetic field-lines. Thus, in low-beta plasmas the slow wave is a sound wave modified by the presence of the magnetic field.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"In reality, waves can be mixed together with mode conversions. Also, notice that the classical wave theory is based on spatially homogeneous plasma assumption, which is rarely the case in nature such as the magnetosphere.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"A tricky part in practice is how to get the average through smoothing. Note that a real satellite moves both in time and space. Usually people do moving-box-average to get an average state within a short period.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"A more careful analysis is called Walén test.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"However, always keep in mind that the most reliable way of identifying waves is to calculate the dispersion relation.","category":"page"},{"location":"man/analysis/#Correlation-Test-Between-Two-Variables","page":"Data Analysis in Space Physics","title":"Correlation Test Between Two Variables","text":"","category":"section"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"This part takes the reference from R.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Correlation test is used to evaluate the association between two or more variables.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"info: Info\nIf there is no relationship between the two variables, the average of x should be the same regardless of y and vice versa.","category":"page"},{"location":"man/analysis/#Methods-for-correlation-analyses","page":"Data Analysis in Space Physics","title":"Methods for correlation analyses","text":"","category":"section"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"There are different methods to perform correlation analysis:","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Pearson correlation (r), which measures a linear dependence between two variables (x and y). It’s also known as a parametric correlation test because it depends to the distribution of the data. It can be used only when x and y are from normal distribution. The plot of y = f(x) is named the linear regression curve.\nKendall tau and Spearman rho, which are rank-based correlation coefficients (non-parametric).","category":"page"},{"location":"man/analysis/#Correlation-formula","page":"Data Analysis in Space Physics","title":"Correlation formula","text":"","category":"section"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"In the formula below,","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"x and y are two vectors of length n\nbarx and bary corresponds to the means of x and y, respectively.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"Pearson correlation formula","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"r = fracsum (x-barx)(y-barysqrtsum(x-barx)^2sum(y-bary)^2","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"The p-value (significance level) of the correlation can be determined :","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"by using the correlation coefficient table for the degrees of freedom : df=n2, where n is the number of observation in x and y variables.","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"2 or by calculating the t value as follows:","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"t = fracrsqrt1-r^2sqrtn-2","category":"page"},{"location":"man/analysis/","page":"Data Analysis in Space Physics","title":"Data Analysis in Space Physics","text":"where the corresponding p-value is determined using t table distribution for df=n-2. If the p-value is  5, then the correlation between x and y is significant.","category":"page"},{"location":"man/trace/#Streamline-and-Trajectory","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"","category":"section"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"Streamline and trajectory are related topics in physical modeling, common seen in fluid and particle simulations. In the future, the stream tracing should become a stand-alone package!","category":"page"},{"location":"man/trace/#Streamline-Tracing","page":"Streamline and Trajectory","title":"Streamline Tracing","text":"","category":"section"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"First make it work, then make it better and fast.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"I found an approach called Pollock method.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"I need an adaptive step control integration scheme like rk45.","category":"page"},{"location":"man/trace/#Tracing-on-Unstructured-Grid","page":"Streamline and Trajectory","title":"Tracing on Unstructured Grid","text":"","category":"section"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"Given an unstructured grid with node points and connectivity, how should you do the streamline tracing?","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"Brute force algorithm:","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"find the grid cell you are currently in;\nmove along the vector direction until you hit the boundary of that cell;\nfind the neighbour who shares the same edge and the intersection point;\nuse the vector direction in the next cell and move along that direction;\nrepeat 2-4 until you reach any of the stopping criteria: hit the boundary, exceed MaxIteration, or exceed MaxLength.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"Some questions during the process:","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"How to find the neighbouring cell?\nHow to determine which boundary edge will you cross?\nHow to improve the search speed?\nHow to improve accuracy?","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"A package called UnstructuredGrids.jl already exists. I take advantage of this package and quickly build a 2D stream tracer on unstructured 2D grid based on the brute force algorithm.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"Actually, this may not be as bad as you think in terms of accuracy. Finite volume method uses one value per cell to represent the solution space, therefore it is just cheating to use higher order method for stream tracing.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"An example is shown for the 2D streamline tracing in the unstructured triangular mesh for the famous airfoil problem. The blue lines are the analytic stream functions derived from incompressible Euler equations which are calculated numerically. Three colored lines are displayed with dots representing the footprint inside each cell.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"(Image: )","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"An extension to 3D is possible, and is WIP.","category":"page"},{"location":"man/trace/#Matlab","page":"Streamline and Trajectory","title":"Matlab","text":"","category":"section"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"There is an implementation of streamline tracing in Matlab called tristream. It requires nodal data.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"Inside the function, there is an intrinsic function called pointLocation, which returns the index of cell where the point locates.","category":"page"},{"location":"man/trace/#yt","page":"Streamline and Trajectory","title":"yt","text":"","category":"section"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"There is another implementation in yt library, which has many similarities to the one I borrowed from SpacePy.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"Streamlining through a volume is useful for a variety of analysis tasks. By specifying a set of starting positions, the user is returned a set of 3D positions that can, in turn, be used to visualize the 3D path of the streamlines. Additionally, individual streamlines can be converted into YTStreamline objects, and queried for all the available fields along the streamline.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"The implementation of streamlining in yt is described below.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"Decompose the volume into a set of non-overlapping, fully domain tiling bricks, using the AMRKDTree homogenized volume.\nFor every streamline starting position:","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"While the length of the streamline is less than the requested length:\nFind the brick that contains the current position\nIf not already present, generate vertex-centered data for the vector fields defining the streamline.\nWhile inside the brick\nIntegrate the streamline path using a Runge-Kutta 4th order method and the vertex centered data.\nDuring the intermediate steps of each RK4 step, if the position is updated to outside the current brick, interrupt the integration and locate a new brick at the intermediate position.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"The set of streamline positions are stored in the Streamlines object.","category":"page"},{"location":"man/trace/#VTK-Implementation","page":"Streamline and Trajectory","title":"VTK Implementation","text":"","category":"section"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"In the VTK library, there is a class called vtkPointLocator. It is a spatial search object to quickly locate points in 3D. vtkPointLocator works by dividing a specified region of space into a regular array of \"rectangular\" buckets, and then keeping a list of points that lie in each bucket. Typical operation involves giving a position in 3D and finding the closest point. It supports both nodal data and cell data.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"vtkPointLocator has two distinct methods of interaction. In the first method, you supply it with a dataset, and it operates on the points in the dataset. In the second method, you supply it with an array of points, and the object operates on the array.","category":"page"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"note: Note\nMany other types of spatial locators have been developed such as octrees and kd-trees. These are often more efficient for the operations described here.","category":"page"},{"location":"man/trace/#Particle-Tracing","page":"Streamline and Trajectory","title":"Particle Tracing","text":"","category":"section"},{"location":"man/trace/","page":"Streamline and Trajectory","title":"Streamline and Trajectory","text":"I have a plan of incorporating particle tracing into this module. WIP","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Examples of data loading are in Batsrus.jl. You can use all the functions in Batsrus.jl by, e.g., VisAna.readdata, or you can just import the packge by using Batsrus.","category":"page"},{"location":"man/examples/#Quick-exploration-of-data","page":"Examples","title":"Quick exploration of data","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"A general plotdata function is provided for quick visualizations.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"1D binary","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"plotdata(data, \"p\", plotmode=\"line\")\nplotdata(data, \"p\", plotmode=\"linegrid\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"2D Cartesian (structured)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"plotdata(data, \"p bx;by\", plotmode=\"contbar streamover\")\nplotdata(data, \"p bx;by\", plotmode=\"contbar quiverover\")\nplotdata(data, \"p bx;by\", plotmode=\"contbar streamover\", density=2.0)\nplotdata(data, \"p\", plotmode=\"grid\")\nplotdata(data, \"p\", plotmode=\"contbar\", plotrange=[-50., 50., -1., 1.])\nplotdata(data, \"p\", plotmode=\"contbar\")\nplotdata(data, \"p\", plotmode=\"contbarlog\")\nplotdata(data, \"p\", plotmode=\"surfbar\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"2D unstructured","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"plotdata(data, \"rho\", plotmode=\"contbar\")\nplotdata(data, \"rho\", plotmode=\"trimesh\")\nplotdata(data, \"rho\", plotmode=\"tricont\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"2D structured spherical coordinates","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"plotdata(data, \"rho\", plotmode=\"contbar\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"3D box","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"plotdata(data, \"bx\", plotmode=\"contbar\", cut=\"y\", cutPlaneIndex=1, level=20)\nplotdata(data, \"bx\", plotmode=\"contbar\", cut=\"y\", plotrange=[-1.4,-1.1,0.70,0.78])\nusing PyPlot\nplt.axis(\"scaled\")\n\nsubplot(2,2,(1,3))\ncutplot(data, \"Ex\", cut='y', cutPlaneIndex=128, plotrange=plotrange)","category":"page"},{"location":"man/examples/#Multiple-dispatch-for-Matplotlib-functions","page":"Examples","title":"Multiple dispatch for Matplotlib functions","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Using the same plotting functions as in Matplotlib is allowed, and actually recommended. Some plotting functions can be directly called as shown below, which allows for more control from the user. using PyPlot to import the full capability of the package, etc. adding colorbar, changing line colors, setting colorbar range with clim.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"line plot","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"plot(data, \"p\", linewidth=2, color=\"green\")\nc = plot(data, \"p\")\nplt.setp(c, linestyle=\"--\", linewidth=2);","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"scatter plot","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"scatter(data, \"p\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"contour","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# 2D contour\ncontour(data, \"p\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"filled contour","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"contourf(data, \"p\")\ncontourf(data, \"p\", levels, plotrange=[-10,10,-Inf,Inf], plotinterval=0.1)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"surface plot","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"plot_surface(data, \"p\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"triangle surface plot","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"plot_trisurf(data, \"p\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"triangle filled contour plot","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"tricontourf(data, \"p\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"streamline","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"streamplot(data, \"bx;bz\")\nstreamplot(data, \"bx;bz\", density=2.0, color=\"k\", plotinterval=1.0, plotrange=[-10,10,-Inf,Inf])","category":"page"},{"location":"man/examples/#Streamline-tracing","page":"Examples","title":"Streamline tracing","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The built-in streamplot function in Matplotlib is not satisfactory for accurately tracing streamlines. Instead in VisAna we have native support field tracer.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"dipole.jl is used for analytically generate a dipole field:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"test_dipole()","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"which will show the following figure","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Tracing along an asymptotic line","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"test_trace_asymptote()","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"in turn gives (Image: )","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Tracing lines in a dipole field","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"test_trace_dipole()","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"in turn gives (Image: )","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Currently the tracing only works on a uniform structured grid.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"An example of tracing in a 2D cut and plot the field lines over contour:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"using VisAna, PyPlot\n\nfilename = \"y=0_var_1_t00000000_n00000000.out\"\ndata = VisAna.readdata(filename,dir=\"test\")\n\nbx = data.w[:,:,5]\nbz = data.w[:,:,7]\nx  = data.x[:,1,1]\nz  = data.x[1,:,2]\n\nseeds = select_seeds(x,z; nSeed=100) # randomly select the seeding points\n\nfor i = 1:size(seeds)[2]\n   xs = seeds[1,i]\n   zs = seeds[2,i]\n   # Tracing in both direction. Check the document for more options.\n   x1, z1 = trace2d_eul(bx, bz, xs, zs, x, z, ds=0.1, maxstep=1000, gridType=\"ndgrid\")\n   plot(x1,z1,\"--\")\nend\naxis(\"equal\")","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"which will display (Image: BATSRUS_test1_noAMR)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Currently the select_seeds function uses pseudo random number generator that produces the same seeds every time.","category":"page"},{"location":"man/examples/#Space-data-analysis","page":"Examples","title":"Space data analysis","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In the space folder, you can find scripts for comparing magnetic field with observations, cross polar cap potential analysis, diamagnetic current calculation, 1D data frequency analysis, minimum variance analysis, particle phase space distribution plots, cut plots near the X-line reconnection site, and static satellite analysis.","category":"page"},{"location":"man/examples/#Plotting-with-Plots.jl-(experimental)","page":"Examples","title":"Plotting with Plots.jl (experimental)","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"An experimental feature is implemented in visual_plot.jl for using user recipes in the Julia official plotting package. It is currently commented out in visual_plot.jl. The user recipe allows the plotting functions working on a custom type. I do not use Plots.jl simply because it's too slow and lacks many detailed controls.","category":"page"},{"location":"#VisAna.jl-Documentation","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"VisAna.jl Documentation","title":"Overview","text":"","category":"section"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"note: Note\nThis package is still under development, so be careful for any future breaking changes!","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"SWMF data reading, converting, visualizing and analyzing using Julia.","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"This package is inherited from its predecessor in IDL (developed by G.Tóth) and Matlab (developed by H.Zhou). Currently instead of a real \"package\", this is more like a collection of scripts. The data loader and converter is split into an stand-alone package Batsrus.jl.","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"This package provides the following functionalities:","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"simulation data reader\nsimulation data visualization\ndata format conversion\nprogramming language interoperability\ndata analysis in space physics\ntest particle tracing (WIP)","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"The data analysis part includes spectral analysis, minimum variance analysis and many functions for aiding the interpretation of data.","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"The ultimate goal is to build a convenient tool of reading and analyzing simulation outputs which is easy to install, easy to use, and fast.","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"tip: Ready to use?\nFeel free to contact the author for any help or collaboration!","category":"page"},{"location":"#Installation","page":"VisAna.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"Install VisAna from the julia REPL prompt with","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/henry2004y/VisAnaJulia\", rev=\"master\"))","category":"page"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"Pages = [\n    \"man/log.md\",\n    \"man/examples.md\",\n    \"man/functions.md\",\n    \"man/types.md\",\n    \"man/analysis.md\"\n    \"man/trace.md\"\n    \"man/testparticle.md\"\n    \"man/text.md\"\n]\nDepth = 1","category":"page"},{"location":"#Benchmark","page":"VisAna.jl Documentation","title":"Benchmark","text":"","category":"section"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"VisAna has by far the fastest data loading speed among IDL, MATLAB, and Julia. It has almost the same performance as spacepy. Check the table for details.","category":"page"},{"location":"#Developers","page":"VisAna.jl Documentation","title":"Developers","text":"","category":"section"},{"location":"","page":"VisAna.jl Documentation","title":"VisAna.jl Documentation","text":"VisAna is developed by Hongyang Zhou.","category":"page"},{"location":"man/log/#Development-Log","page":"Development Log","title":"Development Log","text":"","category":"section"},{"location":"man/log/#Animation","page":"Development Log","title":"Animation","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"This is a big headache for me right now. The current support of animation in Matplotlib is not good enough, especially for interactive plotting and scanning through multiple snapshots.","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"The color range is also an issue.","category":"page"},{"location":"man/log/#Dependency-and-Package-Structure","page":"Development Log","title":"Dependency and Package Structure","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"As to avoid the cross-dependency hail on PyPlot, I split the original package into pure IO Batsrus.jl and post-processing and plotting. This is also a nicer way of organizing larger code base.","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"Currently VisAna is more of a collection of scripts, instead of a true package. I am planning to build individual packages for each feature, so that others can make more use of what they want specifically.","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"Demos are provided for calling Matlab/Python directly from Julia for debugging and testing. This part will later be separated out for potential Python and Matlab users. Currently the plotting and interpolation needed during plotting are done in Python. For instance, the scattered interpolation is done via Interpolate in Scipy. Hopefully these additional dependencies will be cut down.","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"At first I forgot to export the Data struct, so everytime when I modified the code and rerun plotdata, it will shout error at me, saying no type was found for the input type.","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"Precise control of colorbar position in Matplotlib is not an easy task. axis(“scaled”) or axis(“equal”) will cause issue with the present layout, such as overlapping, cutoff, or too much white spaces. Things are improving, but it takes time. See the scripts in the space folder for some examples of controlling the layouts.","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"The current wrapper over Matplotlib makes it difficult to modify the plots afterwards, which especially causes problems when dealing with time series snapshots. The colorbar is so hard to fix. The solution is, instead of using level, provide a range of points.","category":"page"},{"location":"man/log/#User-Recipe-in-Plots.jl","page":"Development Log","title":"User Recipe in Plots.jl","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"There is a user recipe in Plots. This is exactly what I am looking for, but more issues are coming up. I have created a new branch for this development.","category":"page"},{"location":"man/log/#Scattered-interpolation","page":"Development Log","title":"Scattered interpolation","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"SWMF outputs may be in generalized coordinates. For the purpose of plotting, we often need to first interpolate onto a uniform mesh. Even thought this seems to be a very basic job, I have not yet found a simple solution to do this in native Julia. My current workaround is to call Python:","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"using PyPlot\nn = 100\nX, Y, W = rand(n), rand(n), rand(n)\ninterval = 0.02\nxi = range(minimum(X), stop=maximum(X), step=interval)\nyi = range(minimum(Y), stop=maximum(Y), step=interval)\n# Perform linear interpolation of the data (x,y) on grid(xi,yi)\ntriang = matplotlib.tri.Triangulation(X,Y)\ninterpolator = matplotlib.tri.LinearTriInterpolator(triang, W)\nXi = [y for x in xi, y in yi]\nYi = [x for x in xi, y in yi]\nwi = interpolator(Xi, Yi)","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"There is a package in Julia called ScatteredInterpolation.jl, but unfortunately it does not have simple bilinear interpolation method, and the existing methods in the package costs too much memory. From the author of the package:","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"I would really like to have an implementation of a fast linear method corresponding to the ones in Python or MATLAB. However, these use a Delaunay triangulation of the sampling points, and as far as I know, the only Julia library providing such a triangulation works only in 2D. I started an implementation two years ago by wrapping the Qhull library that both Python and MATLAB use for the Delaunay triangulation, but that was a major pain and I gave up.","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"Actually there is a QHull wrapper in Julia now. But again this is a wrapper over a Python library. In this case I would say: do not reinvent the wheel for no good reasons.","category":"page"},{"location":"man/log/#Wrapper-over-Matplotlib","page":"Development Log","title":"Wrapper over Matplotlib","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"A direct wrapper over PyPlot function is possible, and would be more suitable for passing arguments. This may be a more plausible way to go than relying on recipes.","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"When doing processing in batch mode on a cluster, there's usually no need to render the plots on screen. There exists such a backend for this purpose:","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"using PyPlot\nPyPlot.matplotlib.use(\"Agg\")","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"However, notice that currently Agg backend does not support draw_artist. For example, you cannot add an anchored text to your figure.","category":"page"},{"location":"man/log/#Makie","page":"Development Log","title":"Makie","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"MakieLayout is a nice extension built on top of Makie to create publication quality figures and interactive plots. It basically includes all the funcationalities I want, so definitely worth a try.","category":"page"},{"location":"man/log/#Macros","page":"Development Log","title":"Macros","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"Several places where macros can be used:","category":"page"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"Create a subarray with a name symbol\nReduce wrapper code duplicates","category":"page"},{"location":"man/log/#Streamline","page":"Development Log","title":"Streamline","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"The built-in streamline function of Matplotlib/MATLAB is not proper for scientifically visualizing field information. The solution is to trace field lines with ODEs and plot the line series, similar to what has been done by Spacepy.","category":"page"},{"location":"man/log/#GUI","page":"Development Log","title":"GUI","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"As for the GUI development, GTK seems to be an ideal candidate. However, the interface in Julia lacks full support for the toolkit, which makes it a little bit hard to use.","category":"page"},{"location":"man/log/#Todo-List","page":"Development Log","title":"Todo List","text":"","category":"section"},{"location":"man/log/","page":"Development Log","title":"Development Log","text":"[x] Fixed colorbar control through Matplotlib\n[x] Test suite for checking validity\n[ ] Full coverage of tests\n[x] Cuts from 3D data visualization besides contour\n[ ] Port to Makie\n[x] Field tracer 2D in Julia\n[x] Derived variable support (dropped because of GUI)\n[x] General postprocessing script for concatenating and converting files.\n[x] Direct wrapper over matplotlib functions to get seamless API\n[x] Replace np.meshgrid with list comprehension\n[ ] Find a substitution of triangulation in Julia\n[ ] Allow dot syntax to get dictionary contents (Base.convert?)\n[ ] Macros for quickly looking at data (GUI is the ideal solution!)\n[x] Magnetic field line plots from simulation\n[x] Particle phase space distribution plots\n[ ] Animation\n[ ] Make more separate small packages instead of one giant collection","category":"page"},{"location":"man/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions/#Functions-exported-from-VisAna:","page":"Functions","title":"Functions exported from VisAna:","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Modules = [VisAna]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"man/functions/#PyPlot.contour","page":"Functions","title":"PyPlot.contour","text":"contour(data,var, levels=0; plotrange, plotinterval, kwargs)\n\nWrapper over the contour function in matplotlib.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#PyPlot.contourf","page":"Functions","title":"PyPlot.contourf","text":"contourf(data, var, levels=0; plotrange, plotinterval, kwargs)\n\nWrapper over the contourf function in matplotlib.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#PyPlot.plot-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"PyPlot.plot","text":"plot(data, var; kwargs)\n\nWrapper over the plot function in matplotlib.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#PyPlot.plot_surface-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"PyPlot.plot_surface","text":"plot_surface(data, var; plotrange, plotinterval, kwargs)\n\nWrapper over the plot_surface function in matplotlib.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#PyPlot.plot_trisurf-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"PyPlot.plot_trisurf","text":"plot_trisurf(data::Data, var::String;\n\tplotrange::Vector{Float64}=[-Inf,Inf,-Inf,Inf], kwargs::Dict=Dict())\n\nWrapper over the plot_trisurf function in matplotlib.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#PyPlot.scatter-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"PyPlot.scatter","text":"scatter(data, var; kwargs)\n\nWrapper over the scatter function in matplotlib.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#PyPlot.streamplot-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"PyPlot.streamplot","text":"streamplot(data, var; plotrange, plotinterval=0.1, density=1.0, color=\"\")\n\nWrapper over the streamplot function in matplotlib. Streamplot does not have **kwargs in the API.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#PyPlot.tricontourf-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"PyPlot.tricontourf","text":"tricontourf(data, var; plotrange, plotinterval, kwargs)\n\nWrapper over the tricontourf function in matplotlib.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.animatedata-Tuple{}","page":"Functions","title":"VisAna.animatedata","text":"animatedata()\n\nGenerate animations from data. This is basically calling plotdata function for multiple snapshots. The main issue here is to determine the colorbar/axis range in advance to avoid any jump in the movie.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.cutplot-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"VisAna.cutplot","text":"cutplot(data, var; plotrange=[-Inf,Inf,-Inf,Inf], cut=' ',\n\tplotinterval=0.1, density=1.0, cutPlaneIndex=1,level=20)\n\n2D plane cut contourf of 3D box data.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.plotdata-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"VisAna.plotdata","text":"plotdata(data, func, (...))\n\nPlot the variable from SWMF output.\n\nplotdata(data, \"p\", plotmode=\"contbar\")\n\nplotdata(data, \"p\", plotmode=\"grid\")\n\nplotdata(data, func, plotmode=\"trimesh\",plotrange=plotrange, plotinterval=0.2)\n\nInput arguments\n\ndata::Data: output data.\nfunc::String: variables for plotting.\nplotmode::String: (optional) type of plotting [\"cont\",\"contbar\"]...\nplotrange::Vector: (optional) range of plotting.\nplotinterval: (optional) interval for interpolation.\nlevel: (optional) level of contour.\ndensity: (optional) density for streamlines.\ncut: (optional) select 2D cut plane from 3D outputs [\"x\",\"y\",\"z\"].\ncutPlaneIndex: (optional)\nmultifigure: (optional) 1 for multifigure display, 0 for subplots.\nverbose: (optional) display additional information.\n\nRight now this can only deal with 2D plots or 3D cuts. Full 3D plots may be supported in the future.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.plotlogdata-Tuple{Any,NamedTuple,AbstractString}","page":"Functions","title":"VisAna.plotlogdata","text":"plotlogdata(data, head, func, plotmode=\"line\")\n\nPlot information from log file.\n\nInput arguments\n\ndata::Array: output data.\nhead::NamedTuple: header info.\nfunc::String: variables for plotting.\nplotmode::String: type of plotting [\"line\",\"scatter\"].\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.select_seeds-Tuple{Any,Any}","page":"Functions","title":"VisAna.select_seeds","text":"select_seeds(x, y, nSeed=100)\n\nGenerate nSeed seeding points randomly in the grid range. If you specify nSeed, use the keyword input, otherwise it will be overloaded by the 3D version seed generation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.streamslice-Tuple{Batsrus.Data,AbstractString}","page":"Functions","title":"VisAna.streamslice","text":"streamslice(data::Data, var::String;\n  plotrange=[-Inf,Inf,-Inf,Inf], cut=' ',\n  plotinterval=0.1, density=1.0, cutPlaneIndex=1,color=\"w\")\n\nPlot streamlines on 2D slices of 3D box data. Variable string must be separated with ;. Tranposes aree needed because of meshgrid and ndgrid conversion.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.test_dipole-Tuple{}","page":"Functions","title":"VisAna.test_dipole","text":"A quick test of the dipole field functions.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.test_trace_asymptote","page":"Functions","title":"VisAna.test_trace_asymptote","text":"testtraceasymptote(IsSingle)\n\nTest streamline tracing by plotting vectors and associated streamlines through a simple velocity field where Vx=x, Vy=-y. Support test for single and double precision.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#VisAna.test_trace_dipole-Tuple{}","page":"Functions","title":"VisAna.test_trace_dipole","text":"Trace field lines through a dipole field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.trace2d_eul-NTuple{6,Any}","page":"Functions","title":"VisAna.trace2d_eul","text":"trace2d_eul(fieldx, fieldy, xstart, ystart, gridx, gridy;\n\tmaxstep=20000, ds=0.01, gridType=\"meshgrid\", direction=\"both\")\n\nGiven a 2D vector field, trace a streamline from a given point to the edge of the vector field. The field is integrated using Euler's method. While this is faster than rk4, it is less accurate. Only valid for regular grid with coordinates gridx, gridy. If gridx and gridy are not given, assume that xstart and ystart are normalized coordinates (e.g. position in terms of array indices.)??? The field can be in both meshgrid (default) or ndgrid format. Supporting direction for {\"both\",\"forward\",\"backward\"}.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.trace2d_rk4-NTuple{6,Any}","page":"Functions","title":"VisAna.trace2d_rk4","text":"trace2d_rk4(fieldx, fieldy, xstart, ystart, gridx, gridy;\n\tmaxstep=20000, ds=0.01, gridType=\"meshgrid\", direction=\"both\")\n\nGiven a 2D vector field, trace a streamline from a given point to the edge of the vector field. The field is integrated using Runge Kutta 4. Slower than Euler, but more accurate. The higher accuracy allows for larger step sizes ds.  Only valid for regular grid with coordinates gridx, gridy. If gridx and gridy are not given, assume that xstart and ystart are normalized coordinates (e.g., position in terms of array indices.???) The field can be in both meshgrid (default) or ndgrid format. Supporting direction for {\"both\",\"forward\",\"backward\"}.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#VisAna.trace3d_eul-NTuple{9,Any}","page":"Functions","title":"VisAna.trace3d_eul","text":"trace3d_eul(fieldx, fieldy, fieldz, xstart, ystart, zstart, gridx, gridy,\n  gridz; maxstep=20000, ds=0.01)\n\nGiven a 3D vector field, trace a streamline from a given point to the edge of the vector field. The field is integrated using Euler's method. Only valid for regular grid with coordinates gridx, gridy, gridz. The field can be in both meshgrid (default) or ndgrid format.\n\n\n\n\n\n","category":"method"}]
}
