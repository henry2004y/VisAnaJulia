var documenterSearchIndex = {"docs":
[{"location":"man/parker_spiral/#Interplanetary-Magnetic-Field","page":"Parker Spiral","title":"Interplanetary Magnetic Field","text":"","category":"section"},{"location":"man/parker_spiral/","page":"Parker Spiral","title":"Parker Spiral","text":"The interplanetary magnetic field (IMF), also called Parker spiral, is the component of the solar magnetic field that is dragged out from the solar corona by the solar wind flow to fill the Solar System. Depending on the polarity of the photospheric footpoint, the heliospheric magnetic field spirals inward or outward; the magnetic field follows the same shape of spiral in the northern and southern parts of the heliosphere, but with opposite field direction. These two magnetic domains are separated by a current sheet (an electric current that is confined to a curved plane). This heliospheric current sheet has a shape similar to a twirled ballerina skirt, and changes in shape through the solar cycle as the Sun's magnetic field reverses about every 11 years. ","category":"page"},{"location":"man/parker_spiral/","page":"Parker Spiral","title":"Parker Spiral","text":"References: Richard Fitzpatrick Mathematica[1]","category":"page"},{"location":"man/parker_spiral/","page":"Parker Spiral","title":"Parker Spiral","text":"[1]: many equations in the Mathematic page assume that θ=π/2, so that sin(θ) term is missing!","category":"page"},{"location":"man/parker_spiral/","page":"Parker Spiral","title":"Parker Spiral","text":"using PyPlot\n\n# Solar\nconst Tsolarrotate = 25.05*24*3600 # [s]\nconst ωsun = 2π / Tsolarrotate # [rad/s]\nconst Rsun = 696340e3 # solar radius, [m]\nconst AU = 1.496e11 # sun-Earth distance, [m]\n\n# Distance from sun\n# https://www.enchantedlearning.com/subjects/astronomy/planets/\nconst dMercury = 0.39  # [AU], 57.91e9 [m]\nconst dVenus   = 0.723 # [AU], 108.2e9 [m]\nconst dMars    = 1.524 # [AU], 227.9e9 [m]\nconst dJupiter = 5.203 # [AU], 778.5e9 [m]\nconst dSaturn  = 9.539 # [AU], 1434e9  [m]\nconst dUranus  = 19.18 # [AU], 2871e9  [m]\nconst dNeptune = 30.06 # [AU], 4495e9  [m]\n\nconst Vr = 300e3 # [m/s]\nconst rmin = 1.0*Rsun # inner radius, [m]\nconst rmax = 5.3*AU # outer radius, [m]\n\n# 2D ecliptic plane\nφ₀ = 0\nr = range(rmin, rmax, length=300)\nφ = @. 2π *( φ₀ + rmin*ωsun/Vr*(r/rmin - log(r) - 1 + log(rmin)) )\n\nfig = figure(\"Ecliptic plane\",figsize=(10,10))\nax = PyPlot.axes(polar=\"true\")\nax.plot(φ, r./AU, label=\"Parker spiral\")\n\nrCircle = ones(100)\nangle = range(0, 2π, length=100)\n\nax.plot(angle, rCircle, \"k--\", label=\"Earth\")\nax.plot(angle, rCircle.*dMercury, \"--\", label=\"Mercury\")\nax.plot(angle, rCircle.*dVenus, \"--\", label=\"Venus\")\nax.plot(angle, rCircle.*dMars, \"--\", label=\"Mars\")\nax.plot(angle, rCircle.*dJupiter, \"--\", label=\"Jupiter\")\n\nax.set_rmax(rmax/AU)\nax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line\nax.grid(true)\nlegend()\n\nax.set_title(\"Interplanetary Magnetic Field In the Ecliptic Plane\", va=\"bottom\")","category":"page"},{"location":"man/parker_spiral/","page":"Parker Spiral","title":"Parker Spiral","text":"# 3D\nnr, nθ = 10, 50\nr_range = range(rmin, rmax, length=nr)\nθ_range = range(π/16, π*15/16, length=nθ)\n\n# meshgrid like operation\nr = r_range' .* ones(nθ)\nθ = ones(nr)' .* θ_range\n\nfig = plt.figure(\"3D\", figsize=(10,6))\nusing3D()\nax = fig.gca(projection=\"3d\")\n\nfor i = 1:1\n   φ₀ = i*π/4\n   φ = @. 2π *( φ₀ + rmin*ωsun/Vr*(r/rmin - log(r) - 1 + log(rmin)) )\n\n   X = @. r * sin(θ) * cos(φ) / AU\n   Y = @. r * sin(θ) * sin(φ) / AU\n   Z = @. r * cos(θ) / AU\n\n   ax.scatter(X, Y, Z)\n   #ax.plot_surface(X, Y, Z, alpha=0.3)\nend\n\nxlabel(\"x [AU]\")\nylabel(\"y [AU]\")\nzlabel(\"z [AU]\")","category":"page"},{"location":"man/text/#Text-Data-Processing","page":"Text Data Processing","title":"Text Data Processing","text":"","category":"section"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"Now it is an age of big data. The fundamental of big data is how to process data efficiently. This section is about text data processing, including data organization, regular expression, and web scraping.","category":"page"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"Examples can be found in the timing folder.","category":"page"},{"location":"man/text/#Data-Format","page":"Text Data Processing","title":"Data Format","text":"","category":"section"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"There are two basic packages for reading/writing ascii data:","category":"page"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"DelimitedFiles\nCSV","category":"page"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"The first one is a built-in package for handling relatively simple data, while the second one is for handling complicated data with seamless support for DataFrame.","category":"page"},{"location":"man/text/#Regular-Expression","page":"Text Data Processing","title":"Regular Expression","text":"","category":"section"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"Julia has built-in support for regular expressions. The best reference and tool I have ever used for regular expression in general is RegExr.","category":"page"},{"location":"man/text/#Web-Scraping","page":"Text Data Processing","title":"Web Scraping","text":"","category":"section"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"Packages worth mentioning:","category":"page"},{"location":"man/text/","page":"Text Data Processing","title":"Text Data Processing","text":"HTTP\nGumbo\nCascadia","category":"page"},{"location":"man/analysis/#Data-Analysis-in-Space-Physics","page":"Analysis","title":"Data Analysis in Space Physics","text":"","category":"section"},{"location":"man/analysis/#Diffusion-Region-Detection","page":"Analysis","title":"Diffusion Region Detection","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Magnetic reconnection occurs in a small diffusion region around the X-line but its consequences are large scale. There are different approaches to determine whether or not we have encountered the diffusion region. The expected kinetic signatures of diffusion region:","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"enhanced dissipation\nnon-gyrotropic behavior\nelectron distribution functions","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The first proposed non-gyrotropy measure by Jack Scudder and William Daughton is","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"AØ_e = 2fracP_perp1 - P_perp2P_perp1 + P_perp2","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"which only considers the non-gyrotropy in the plane perpendicular to the magnetic field.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Another measure of non-gyrotropy D_ng of a specific population proposed by researchers can be think of a ratio between off-diagonal terms and diagonal terms of the pressure tensor:","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"D_ng = frac2sqrtsum_ij ineq jP_ij^2sum_i=13P_ii^2","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Note that this is frame independent and population specific.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"However, Marc Swisdak later demonstrated in his paper that a better measure from positive semi-definite matrix analysis should be","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Q = fracP_12^2 + P_23^2 + P_31^2P_perp^2 + 2P_perp P_parallel = 1- 4fracI_2(I_1 - P_parallel)(I_1 + 3P_parallel)","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where I_1=P_xx+P_yy+P_zz is the trace and I_2=P_xxP_yy+P_xxP_zz+P_yyP_zz-(P_xyP_yx+P_xzP_zx+P_yzP_zy) is the principle minor, both of which are invariants under coordinate rotation. (The third invariant is the determinant.) This indeed peak near the center of X-line while is enhanced along the separatrices, which is better than D_ng in the sense that the latter may not peak at the diffusion region.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"It has been found from PIC simulations that especially in asymmetric reconnection, E_M^astneq 0 where mathbfE^ast=mathbfE+mathbfV_etimesmathbfB is not a good enough indicator. Following the principle ideas of finding a measure:","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"dissipation should be related to non-ideal energy conversion;\nscalar indicator;\ninsensitive to the relative motion,","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"a frame independent dissipation measure is constructed,","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"D_e = gamma_ebigmathbfJcdot(mathbfE+mathbfV_etimesmathbfB) - (n_i - n_e)(mathbfV_etimesmathbfE)big","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"which is a Lorentz-invariant scalar representing the energy conversion rate in the frame of electron bulk motion. In the nonrelativistic limit, one can simplify the equation by setting gamma_erightarrow 1. This can be easily confirmed by multiplying mathbfj^prime=qn_imathbfV_i=mathbfj-rho_cmathbfV_e and mathbfE^prime = mathbfE+mathbfVtimesmathbfB.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"This is another good indicator of the electron diffusion region, although it is slightly enhanced along the separatrices as well.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"An alternative and complementary approach is to identify diffusion region candidates by a combination of representative properties. In practice for reconnection with no guide field for instance, the overlapped region of B_L=0 and E_N peak, where some researchers call 'shoulder', is already good enough for the identification.","category":"page"},{"location":"man/analysis/#Spectral-Analysis","page":"Analysis","title":"Spectral Analysis","text":"","category":"section"},{"location":"man/analysis/#FFT","page":"Analysis","title":"FFT","text":"","category":"section"},{"location":"man/analysis/#Periodogram","page":"Analysis","title":"Periodogram","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"This is a group of techniques to determine the periodicity of data. Essentially it is the same as Fourier transform, but with the inverse of frequency as the x axis. Julia has implementations in the DSP package. Here we introduce the usage by looking at practical examples.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"note: Note\nBe careful of any smoothing you apply to the raw data. It is very easy to forget about the tricks you use in analyzing raw data and come up with a biased conclusion.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"A Savitzky-Golay filter can be used to smooth data before applying any further analysis. The idea is to use local polynomial approximations to replace the original data.","category":"page"},{"location":"man/analysis/#Spectrogram","page":"Analysis","title":"Spectrogram","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Spectrogram is used a lot in wave analysis. For my purpose, I use it as an approach to visualize time dependent simulation data along a continuous line region.","category":"page"},{"location":"man/analysis/#Minimum-Variance-Analysis","page":"Analysis","title":"Minimum Variance Analysis","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"A nice introduction is given by Bengt U.Ö.Sonnerup and Maureen Scheible.  Here is a brief summary of the idea. The implementation of MVA can be found in  MVA.jl.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The main purpose of minimum or maximum variance analysis (MVA) is to find, from single-spacecraft data, an estimator for the direction normal to a one-dimensional or approximately one-dimensional current layer, wave front, or other transition layer in a plasma.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"For real transition layers observed in space there are usually more or less pronounced deviations from the ideal 1-D model. The layer is likely to have 2-D or 3-D internal structures which evolve in time and to have temporal fluctuations in the orientation of its normal as well.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The minimum variance technique is designed to deal with the situation where some or all of the non-ideal effects mentioned above, except a systematic temporal change in the normal direction, widehatn, are present. As the estimate of  widehatn, the method identifies that direction in space along which the field-component set {mathbfB^(m)cdotwidehatn} (m = 1 2 3M)  has minimum variance. In other words, widehatn is determined by  minimisation of","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"sigma^2 = frac1M sum_m=1^M (mathbfB^(m) - mathbfB)cdotwidehatn ^2","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where the average langlemathbfBrangle is defined by","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"langlemathbfBrangle equiv frac1M sum_m=1^M mathbfB^(m)","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"and where the minimisation is subject to the normalisation constraint widehatn=1. Using a Lagrange multiplier lambda to implement this constraint, one then seeks the solution of the set of three homogeneous linear equations","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"fracpartialpartial n_xBig( sigma^2 - lambda (widehatn^2 - 1) Big) = 0 \nfracpartialpartial n_yBig( sigma^2 - lambda (widehatn^2 - 1) Big) = 0 \nfracpartialpartial n_zBig( sigma^2 - lambda (widehatn^2 - 1) Big) = 0","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where sigma^2 is given by the equation above and widehatn is represented in terms of its three components (n_x n_y n_z) along the cartesian coordinate system X, Y, Z (e.g., GSE or GSM) in which the field data mathbfB^(m)  are given. When the differentiations in equations above have been performed, the resulting set of three equations can be written in matrix form as","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"sum_nu=1^3 M_munu^B n_nu = lambda n_mu","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where the subscripts munu = 123 denote cartesian components along the X, Y, Z system and","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"M_munu^B equiv langle B_mu B_nurangle - langle B_muranglelangle B_nurangle","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"is the magnetic variance matrix. It is seen from the equation that the allowed lambda values are the eigenvalues lambda_1lambda_2lambda_3 (given here in order of decreasing magnitude) of M_munu^B. Since M_munu^B is symmetric, the eigenvalues are all real and the corresponding eigenvectors, x_1, x_2, and x_3, are orthogonal. The three eigenvectors represent the directions of maximum, intermediate, and minimum variance of the field component along each vector.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"note: Note\nIn practice, the ratio of intermediate to minimum variance should be larger than 5 to give good fit of LMN.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"A not so good example case is the Galileo G8 Ganymede flyby magnetometer data: (Image: ) where the ratio between the intermediate and minimum eigenvalue is only about 2.","category":"page"},{"location":"man/analysis/#ULF-Wave-Detection","page":"Analysis","title":"ULF Wave Detection","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"ULF waves are MHD waves: Alfvén wave, fast wave and slow wave. One basic approach to identify waves is to check the correlation of quantity perturbations.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The phase speed of shear Alfvén wave is","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"v_pA = fracomegak = v_A costheta","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where v_A is the Alfvén speed and theta is the angle between wave vector mathbfk and magnetic field mathbfB.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The perturbed quantities of Alfvén waves follow these relations:","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"fracdelta mathbfvv_A = pm fracdelta mathbfBB_0 \ndelta rho = 0","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where delta mathbfv, delta mathbfB, and delta rho are perturbed plasma velocity, magnetic fields, and plasma density, respectively, and B_0 is the background magnetic magnitude.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"For slow and fast waves, the phase speeds are","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"v_ppm^2 = big(fracomegak big) = frac12(v_s^2 + v_A^2) pm frac12Big (v_s^2 + v_A^2)^2 - 4v_s^2 v_A^2 cos^2thetaBig^12","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The \"+\" is for fast waves and \"−\" for slow waves, and v_S is the sound speed. The perturbed quantities for fast and slow waves are","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"delta rho = fracrho_0v_pfracv_A^2sinthetaB_0 (v_p - v_s^2v_p)delta B\ndelta mathbfv = -fracv_A^2 costhetaB_0 v_pdeltamathbfB + fracv_A^2 sinthetadelta BB_0 (v_p - v_s^2v_p)fracmathbfkk","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Thus generally the Alfvén wave is identified by the correlations between velocity and magnetic field perturbations, and the fast and slow waves are identified by the negative (for slow waves) or positive (for fast waves) correlations between either density and magnetic field perturbation or thermal pressure and magnetic pressure perturbation.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The second equation above can also be expressed in terms of magnetic and thermal pressure pertubations:","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"delta P_B = fracmathbfB_0 cdot mathbfBmu_0\n=fracV_A^2V_S^2left(1-frack^2 V_S^2 cos^2thetaomega^2right)delta P_t","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"See the lecture notes for more details.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"For the magnetosonic waves, consider using delta mathbfE and delta mathbfB for identifying speed. The slopes of the curves delta Edelta B correspond to the wave propagation speed in the spacecraft frame.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Transverse and shear Alfvén wave refer to actually the same thing: the descriptions arise from  mathbfkcdotmathbfV=0 and mathbfVcdotmathbfB_0=0.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The fast and slow magnetosonic waves are associated with non-zero perturbations in the plasma density and pressure, and also involve plasma motion parallel, as well as perpendicular, to the magnetic field. The latter observation suggests that the dispersion relations omega=kV_pm are likely to undergo significant modification in collisionless plasmas. In order to better understand the nature of the fast and slow waves, let us consider the cold-plasma limit, which is obtained by letting the sound speed V_S tend to zero. In this limit, the slow wave ceases to exist (in fact, its phase velocity tends to zero) whereas the dispersion relation for the fast wave reduces to","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"omega = kV_A","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"This can be identified as the dispersion relation for the compressional-Alfvén wave. Thus, we can identify the fast wave as the compressional-Alfvén wave modified by a non-zero plasma pressure.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"In the limit V_Agg V_S, which is appropriate to low-beta plasmas, the dispersion relation for the slow wave reduces to","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"omega simeq kV_Scostheta","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"This is actually the dispersion relation of a sound wave propagating along magnetic field-lines. Thus, in low-beta plasmas the slow wave is a sound wave modified by the presence of the magnetic field.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"In reality, waves can be mixed together with mode conversions. Also, notice that the classical wave theory is based on spatially homogeneous plasma assumption, which is rarely the case in nature such as the magnetosphere.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"A tricky part in practice is how to get the average through smoothing. Note that a real satellite moves both in time and space. Usually people do moving-box-average to get an average state within a short period.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"A more careful analysis is called Walén test.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"However, always keep in mind that the most reliable way of identifying waves is to calculate the dispersion relation.","category":"page"},{"location":"man/analysis/#Correlation-Test-Between-Two-Variables","page":"Analysis","title":"Correlation Test Between Two Variables","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"This part takes the reference from R.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Correlation test is used to evaluate the association between two or more variables.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"info: Info\nIf there is no relationship between the two variables, the average of x should be the same regardless of y and vice versa.","category":"page"},{"location":"man/analysis/#Methods-for-correlation-analyses","page":"Analysis","title":"Methods for correlation analyses","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"There are different methods to perform correlation analysis:","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Pearson correlation (r), which measures a linear dependence between two variables (x and y). It’s also known as a parametric correlation test because it depends to the distribution of the data. It can be used only when x and y are from normal distribution. The plot of y = f(x) is named the linear regression curve.\nKendall tau and Spearman rho, which are rank-based correlation coefficients (non-parametric).","category":"page"},{"location":"man/analysis/#Correlation-formula","page":"Analysis","title":"Correlation formula","text":"","category":"section"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"In the formula below,","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"x and y are two vectors of length n\nbarx and bary corresponds to the means of x and y, respectively.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"Pearson correlation formula","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"r = fracsum (x-barx)(y-barysqrtsum(x-barx)^2sum(y-bary)^2","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"The p-value (significance level) of the correlation can be determined :","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"by using the correlation coefficient table for the degrees of freedom : df=n2, where n is the number of observation in x and y variables.","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"2 or by calculating the t value as follows:","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"t = fracrsqrt1-r^2sqrtn-2","category":"page"},{"location":"man/analysis/","page":"Analysis","title":"Analysis","text":"where the corresponding p-value is determined using t table distribution for df=n-2. If the p-value is  5, then the correlation between x and y is significant.","category":"page"},{"location":"man/examples/#Examples","page":"Example","title":"Examples","text":"","category":"section"},{"location":"man/examples/#Space-data-analysis","page":"Example","title":"Space data analysis","text":"","category":"section"},{"location":"man/examples/","page":"Example","title":"Example","text":"You can find scripts for comparing magnetic field with observations, cross polar cap potential analysis, diamagnetic current calculation, 1D data frequency analysis, minimum variance analysis, particle phase space distribution plots, cut plots near the X-line reconnection site, and static satellite analysis.","category":"page"},{"location":"#VisAna.jl-Documentation","page":"Home","title":"VisAna.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is still under development, so be careful for any future breaking changes!","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWMF data reading, converting, visualizing and analyzing using Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is inherited from its predecessor in IDL (developed by G.Tóth) and Matlab (developed by H.Zhou). Currently instead of a real \"package\", this is more like a collection of scripts. The data loader and converter is split into an stand-alone package Batsrus.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides the following functionalities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWMF simulation data visualization\nphase space distribution\n2D slices of 3D data, including all common plots\nlog variable plots\ndata analysis in space physics\nmagnetic field comparison with satellite data\nspectral analysis\nminimum variance analysis\nwave analysis","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ultimate goal is to build a convenient tool of reading and analyzing simulation outputs which is easy to install, easy to use, and fast.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Ready to use?\nFeel free to contact the author for any help or collaboration!","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install VisAna from the julia REPL prompt with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/henry2004y/VisAnaJulia\", rev=\"master\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/log.md\",\n    \"man/examples.md\",\n    \"man/functions.md\",\n    \"man/types.md\",\n    \"man/analysis.md\"\n    \"man/trace.md\"\n    \"man/text.md\"\n]\nDepth = 1","category":"page"},{"location":"#Benchmark","page":"Home","title":"Benchmark","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VisAna has by far the fastest data loading speed among IDL, MATLAB, and Julia. It has almost the same performance as spacepy. Check the table for details.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VisAna is developed by Hongyang Zhou.","category":"page"},{"location":"man/internal/#Public-APIs","page":"Internal","title":"Public APIs","text":"","category":"section"},{"location":"man/internal/","page":"Internal","title":"Internal","text":"Modules = [SpaceAnalysis]\nPrivate = false\nOrder = [:type, :function]","category":"page"},{"location":"man/internal/#SpaceAnalysis.MVA-Tuple{Any, Any, Any}","page":"Internal","title":"SpaceAnalysis.MVA","text":"MVA(Bx, By, Bz; verbose=true)\n\nIf the λ1 > λ2 > λ3 are 3 eigenvalues of the matrix M, then a good indicator of nice fitting LMN coordinate system should have λ2/λ3 > 5.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#SpaceAnalysis.mag2db-Tuple{Any}","page":"Internal","title":"SpaceAnalysis.mag2db","text":"Convert x from magnitude to decibels.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#SpaceAnalysis.read_satellite_data-Tuple{Any}","page":"Internal","title":"SpaceAnalysis.read_satellite_data","text":"Import satellite data. Require one line header presented.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#SpaceAnalysis.sma","page":"Internal","title":"SpaceAnalysis.sma","text":"sma(x, n=(5,5))\n\nSimple moving average of x with n[1] leading and n[2] trailing points. Default boundary is \"replicate\", meaning that the border pixels extend beyond the boundaries.\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#SpaceAnalysis.sma-2","page":"Internal","title":"SpaceAnalysis.sma","text":"sma(x, n=100)\n\nSimple moving box average of the vector data x with box length 'n'. One-sided average on the left and right edge with replicate border.\n\n\n\n\n\n","category":"function"},{"location":"man/log/#Development-Log","page":"Log","title":"Development Log","text":"","category":"section"},{"location":"man/log/#Animation","page":"Log","title":"Animation","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"This is a big headache for me right now. The current support of animation in Matplotlib is not good enough, especially for interactive plotting and scanning through multiple snapshots.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"The color range is also an issue.","category":"page"},{"location":"man/log/#Dependency-and-Package-Structure","page":"Log","title":"Dependency and Package Structure","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"As to avoid the cross-dependency hell on PyPlot, I split the original package into pure IO Batsrus.jl and post-processing and plotting. This is also a nicer way of organizing larger code base. Furthermore, after Julia 1.6, the Python style import A as B and using LinearAlgebra: cholesky as c, lu as l are supported. This makes it possible to completely drop the dependency on PyPlot.jl and instead everytime one would need to say using VisAna, PyPlot to trigger the Matplotlib functions. A very nice thing is that I can in principle switch between PyPlot.jl and Plots.jl easily, depending on which package to use!","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Currently VisAna is more of a collection of scripts, instead of a true package. I am planning to build individual packages for each feature, so that others can make more use of what they want specifically. For example, the field tracing and test particle tracing have now become individual modules FieldTracer.jl and TestParticle.jl. Furthermore, these two packages can be merged into one called Tracer.jl.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Demos are provided for calling MATLAB/Python directly from Julia for debugging and testing. This part will later be separated out for potential Python and MATLAB users. Currently the plotting and interpolation needed during plotting are done in Python. For instance, the scattered interpolation is done via Interpolate in Scipy. Hopefully these additional dependencies will be cut down.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"At first I forgot to export the Data struct, so everytime when I modified the code and rerun plotdata, it will shout error at me, saying no type was found for the input type.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Precise control of colorbar position in Matplotlib is not an easy task. axis(“scaled”) or axis(“equal”) will cause issue with the present layout, such as overlapping, cutoff, or too much white spaces. Things are improving, but it takes time. See the scripts in the space folder for some examples of controlling the layouts.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"The current wrapper over Matplotlib makes it difficult to modify the plots afterwards, which especially causes problems when dealing with time series snapshots. The colorbar is so hard to fix. The solution is, instead of using level, provide a range of points.","category":"page"},{"location":"man/log/#User-Recipe-in-Plots.jl","page":"Log","title":"User Recipe in Plots.jl","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"There is a extremely powerful user recipe in Plots.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Repeatly using the same GKSTerm on Mac will display only white backgrounds in the end.\nBy default Plots uses gr() backend. The GR backend contour plot only accept vector x,y!\nI don't want to have Plots.jl as a dependency. With simple plotting features this can work, but we may encounter issues later. After Julia 1.6 this may be completely solved!\nThere is already a UnitfulRecipes.jl that provides the capability of auto-displaying units in figure labels, and it works smoothly with my user recipe. Amazing.\nI have already built a customized package UnitfulBatsrus.jl and set it as a dependency for VisAna. Instead of the usual u\"km/s\" notation, we just need to use bu\"amucc\".","category":"page"},{"location":"man/log/#Scattered-interpolation","page":"Log","title":"Scattered interpolation","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"SWMF outputs may be in generalized coordinates. For the purpose of plotting, we often need to first interpolate onto a uniform mesh. Even thought this seems to be a very basic job, I have not yet found a simple solution to do this in native Julia. My current workaround is to call Python:","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"using PyPlot\nn = 100\nX, Y, W = rand(n), rand(n), rand(n)\ninterval = 0.02\nxi = range(minimum(X), stop=maximum(X), step=interval)\nyi = range(minimum(Y), stop=maximum(Y), step=interval)\n# Perform linear interpolation of the data (x,y) on grid(xi,yi)\ntriang = matplotlib.tri.Triangulation(X,Y)\ninterpolator = matplotlib.tri.LinearTriInterpolator(triang, W)\nXi = [y for x in xi, y in yi]\nYi = [x for x in xi, y in yi]\nwi = interpolator(Xi, Yi)","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"There is a package in Julia called ScatteredInterpolation.jl, but unfortunately it does not have simple bilinear interpolation method, and the existing methods in the package costs too much memory. From the author of the package:","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"I would really like to have an implementation of a fast linear method corresponding to the ones in Python or MATLAB. However, these use a Delaunay triangulation of the sampling points, and as far as I know, the only Julia library providing such a triangulation works only in 2D. I started an implementation two years ago by wrapping the Qhull library that both Python and MATLAB use for the Delaunay triangulation, but that was a major pain and I gave up.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Actually there is a QHull wrapper in Julia now. But again this is a wrapper over a Python library. In this case I would say: do not reinvent the wheel for no good reasons.","category":"page"},{"location":"man/log/#Wrapper-over-Matplotlib","page":"Log","title":"Wrapper over Matplotlib","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"A direct wrapper over PyPlot function is possible, and would be more suitable for passing arguments. This may be a more plausible way to go than relying on recipes.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"When doing processing in batch mode on a cluster, there's usually no need to render the plots on screen. There exists such a backend for this purpose:","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"using PyPlot\nPyPlot.matplotlib.use(\"Agg\")","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"However, notice that currently Agg backend does not support draw_artist. For example, you cannot add an anchored text to your figure.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Unlike the user recipes in Plots.jl, using PyPlot.jl would require to have it as a dependency. (This might not be necessary for the upcoming Julia 1.6!)","category":"page"},{"location":"man/log/#Makie","page":"Log","title":"Makie","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"MakieLayout is a nice extension built on top of Makie to create publication quality figures and interactive plots. It basically includes all the funcationalities I want, so definitely worth a try.","category":"page"},{"location":"man/log/#Macros","page":"Log","title":"Macros","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"Several places where macros can be used:","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Create a subarray with a name symbol\nReduce wrapper code duplicates","category":"page"},{"location":"man/log/#Streamline","page":"Log","title":"Streamline","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"The built-in streamline function of Matplotlib/MATLAB is not proper for scientifically visualizing field information. The solution is to trace field lines with ODEs and plot the line series, similar to what has been done by Spacepy.","category":"page"},{"location":"man/log/#GUI","page":"Log","title":"GUI","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"As for the GUI development, GTK seems to be an ideal candidate. However, the GTK interface in Julia lacks full support for the toolkit, which makes it a little bit hard to use. I have only played with it for half a day. You can design the appearance of your window interactively, and save your in an HTML-like file.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Makie is actually good at this, with the underlying OpenGL support.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"At this point GUI is not necessarily needed, if it does not speed up my own workflow.","category":"page"},{"location":"man/log/#Todo-List","page":"Log","title":"Todo List","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"[x] Fixed colorbar control through Matplotlib\n[x] Test suite for checking validity\n[x] Cuts from 3D data visualization besides contour\n[x] Field tracer 2D in Julia\n[x] Derived variable support\n[x] General postprocessing script for concatenating and converting files.\n[x] Direct wrapper over Matplotlib functions to get seamless API\n[x] Replace np.meshgrid with list comprehension\n[x] Magnetic field line plots from simulation\n[x] Particle phase space distribution plots\n[ ] Add FieldTracer.jl and TestParticle.jl to dependencies and create tests\n[ ] Find a substitution of triangulation in Julia\n[ ] Allow dot syntax to get dictionary contents (Base.convert?)\n[ ] Macros for quickly looking at data (GUI is the ideal solution!)\n[ ] Port to Makie\n[ ] Animation\n[ ] Make more separate small packages instead of one giant collection\n[ ] Full coverage of tests","category":"page"},{"location":"man/log/#Learning-from-yt","page":"Log","title":"Learning from yt","text":"","category":"section"},{"location":"man/log/","page":"Log","title":"Log","text":"The yt Project in Python is a much more mature postprocessing package than mine. That's a good place to learn.","category":"page"},{"location":"man/log/","page":"Log","title":"Log","text":"Off-axis slices: very similar to ParaView and other 3D visualization tools provide, make a 2D cut at any direction. This requires a robust interpolation scheme.\nProjection: it is like an integral form of a quantity in a certain direction, and can be weighted or unweighted. It is not a necessary feature, as one can easily implement this once he or she knows how to do make off-axis slices.\nSame interface for both structured and unstructure data: this is important for a larger user base.\nMesh plotting: they provide a method for adding mesh on top of plots. I haven't had a good implementation of this yet.\nCenter: it would be good to give the option of choosing the center of plots.\nUnits: they build a unit system using dictionary themselves. I don't want to reinvent the wheel, so I will just keep an eye on Unitful.jl and yt. What is inherited from IDL in Batsrus.jl needs rewritten.\nProperty control: I don't like the way yt handles figure properties like colorbar, axes, etc. Matplotlib already teaches you how to set these things, and yet again in yt they wrap everything with names they come up with. This is a more of a burden instead of benefit. They do certain things right like set_cmap, but not all of them. The section Further Customization via Matplotlib is all I want to see. Using popular libraries generally means that new comers won't take long to get used to the interfaces, and developers can have a eaiser time developing new features.\nLog scale: symlog for data containing both positive and negative data, and switch to linear scale for small values.","category":"page"}]
}
