<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Development Log · VisAna</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VisAna</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">VisAna.jl Documentation</a></li><li><a class="tocitem" href="../analysis/">Data Analysis in Space Physics</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li class="is-active"><a class="tocitem" href>Development Log</a><ul class="internal"><li><a class="tocitem" href="#Animation"><span>Animation</span></a></li><li><a class="tocitem" href="#Dependency-and-Package-Structure"><span>Dependency and Package Structure</span></a></li><li><a class="tocitem" href="#User-Recipe-in-Plots.jl"><span>User Recipe in Plots.jl</span></a></li><li><a class="tocitem" href="#Scattered-interpolation"><span>Scattered interpolation</span></a></li><li><a class="tocitem" href="#Wrapper-over-Matplotlib"><span>Wrapper over Matplotlib</span></a></li><li><a class="tocitem" href="#Makie"><span>Makie</span></a></li><li><a class="tocitem" href="#Macros"><span>Macros</span></a></li><li><a class="tocitem" href="#Streamline"><span>Streamline</span></a></li><li><a class="tocitem" href="#GUI"><span>GUI</span></a></li><li><a class="tocitem" href="#Todo-List"><span>Todo List</span></a></li></ul></li><li><a class="tocitem" href="../text/">Text Data Processing</a></li><li><a class="tocitem" href="../types/">Public types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Development Log</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Development Log</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/henry2004y/VisAnaJulia/blob/master/docs/src/man/log.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Development-Log"><a class="docs-heading-anchor" href="#Development-Log">Development Log</a><a id="Development-Log-1"></a><a class="docs-heading-anchor-permalink" href="#Development-Log" title="Permalink"></a></h1><h2 id="Animation"><a class="docs-heading-anchor" href="#Animation">Animation</a><a id="Animation-1"></a><a class="docs-heading-anchor-permalink" href="#Animation" title="Permalink"></a></h2><p>This is a big headache for me right now. The current support of animation in Matplotlib is not good enough, especially for interactive plotting and scanning through multiple snapshots.</p><p>The color range is also an issue.</p><h2 id="Dependency-and-Package-Structure"><a class="docs-heading-anchor" href="#Dependency-and-Package-Structure">Dependency and Package Structure</a><a id="Dependency-and-Package-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Dependency-and-Package-Structure" title="Permalink"></a></h2><p>As to avoid the cross-dependency hell on PyPlot, I split the original package into pure IO <a href="https://github.com/henry2004y/Batsrus.jl">Batsrus.jl</a> and post-processing and plotting. This is also a nicer way of organizing larger code base. Furthermore, after Julia 1.6, the Python style <code>import A as B</code> and <code>using LinearAlgebra: cholesky as c, lu as l</code> are supported. This makes it possible to completely drop the dependency on PyPlot.jl and instead everytime one would need to say <code>using VisAna, PyPlot</code> to trigger the Matplotlib functions. A very nice thing is that I can in principle switch between PyPlot.jl and Plots.jl easily, depending on which package to use!</p><p>Currently VisAna is more of a collection of scripts, instead of a true package. I am planning to build individual packages for each feature, so that others can make more use of what they want specifically. For example, the field tracing and test particle tracing have now become individual modules <a href="https://github.com/henry2004y/FieldTracer.jl">FieldTracer.jl</a> and <a href="https://github.com/henry2004y/TestParticle.jl">TestParticle.jl</a>. Furthermore, these two packages can be merged into one called <em>Tracer.jl</em>.</p><p>Demos are provided for calling MATLAB/Python directly from Julia for debugging and testing. This part will later be separated out for potential Python and MATLAB users. Currently the plotting and interpolation needed during plotting are done in Python. For instance, the scattered interpolation is done via <code>Interpolate</code> in Scipy. Hopefully these additional dependencies will be cut down.</p><p>At first I forgot to export the Data struct, so everytime when I modified the code and rerun plotdata, it will shout error at me, saying no type was found for the input type.</p><p>Precise control of colorbar position in Matplotlib is not an easy task. <code>axis(“scaled”)</code> or <code>axis(“equal”)</code> will cause issue with the present layout, such as overlapping, cutoff, or too much white spaces. Things are improving, but it takes time. See the scripts in the space folder for some examples of controlling the layouts.</p><p>The current wrapper over Matplotlib makes it difficult to modify the plots afterwards, which especially causes problems when dealing with time series snapshots. The colorbar is so hard to fix. The solution is, instead of using <code>level</code>, provide a range of points.</p><h2 id="User-Recipe-in-Plots.jl"><a class="docs-heading-anchor" href="#User-Recipe-in-Plots.jl">User Recipe in Plots.jl</a><a id="User-Recipe-in-Plots.jl-1"></a><a class="docs-heading-anchor-permalink" href="#User-Recipe-in-Plots.jl" title="Permalink"></a></h2><p>There is a <em>extremely powerful</em> user recipe in Plots.</p><ul><li>Repeatly using the same GKSTerm on Mac will display only white backgrounds in the end.</li><li>By default Plots uses <code>gr()</code> backend. The GR backend contour plot only accept vector x,y!</li><li>I don&#39;t want to have <code>Plots.jl</code> as a dependency. With simple plotting features this can work, but we may encounter <a href="https://github.com/JuliaPlots/RecipesBase.jl/issues/72">issues</a> later. After Julia 1.6 this may be completely solved!</li><li>There is already a <a href="https://github.com/jw3126/UnitfulRecipes.jl">UnitfulRecipes.jl</a> that provides the capability of auto-displaying units in figure labels, and it works smoothly with my user recipe. Amazing.</li><li>I have already built a customized package <a href="https://github.com/henry2004y/UnitfulBatsrus.jl.git">UnitfulBatsrus.jl</a> and set it as a dependency for VisAna. Instead of the usual <code>u&quot;km/s&quot;</code> notation, we just need to use <code>bu&quot;amucc&quot;</code>.</li></ul><h2 id="Scattered-interpolation"><a class="docs-heading-anchor" href="#Scattered-interpolation">Scattered interpolation</a><a id="Scattered-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Scattered-interpolation" title="Permalink"></a></h2><p>SWMF outputs may be in generalized coordinates. For the purpose of plotting, we often need to first interpolate onto a uniform mesh. Even thought this seems to be a very basic job, I have not yet found a simple solution to do this in native Julia. My current workaround is to call Python:</p><pre><code class="language-none">using PyPlot
n = 100
X, Y, W = rand(n), rand(n), rand(n)
interval = 0.02
xi = range(minimum(X), stop=maximum(X), step=interval)
yi = range(minimum(Y), stop=maximum(Y), step=interval)
# Perform linear interpolation of the data (x,y) on grid(xi,yi)
triang = matplotlib.tri.Triangulation(X,Y)
interpolator = matplotlib.tri.LinearTriInterpolator(triang, W)
Xi = [y for x in xi, y in yi]
Yi = [x for x in xi, y in yi]
wi = interpolator(Xi, Yi)</code></pre><p>There is a package in Julia called <a href="https://github.com/eljungsk/ScatteredInterpolation.jl">ScatteredInterpolation.jl</a>, but unfortunately it does not have simple bilinear interpolation method, and the existing methods in the package costs too much memory. From the author of the package:</p><blockquote><p>I would really like to have an implementation of a fast linear method corresponding to the ones in Python or MATLAB. However, these use a Delaunay triangulation of the sampling points, and as far as I know, the only Julia library providing such a triangulation works only in 2D. I started an implementation two years ago by wrapping the Qhull library that both Python and MATLAB use for the Delaunay triangulation, but that was a major pain and I gave up.</p></blockquote><p>Actually there is a <a href="https://github.com/JuliaPolyhedra/QHull.jl">QHull</a> wrapper in Julia now. But again this is a wrapper over a Python library. In this case I would say: do not reinvent the wheel for no good reasons.</p><h2 id="Wrapper-over-Matplotlib"><a class="docs-heading-anchor" href="#Wrapper-over-Matplotlib">Wrapper over Matplotlib</a><a id="Wrapper-over-Matplotlib-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-over-Matplotlib" title="Permalink"></a></h2><p>A direct wrapper over PyPlot function is possible, and would be more suitable for passing arguments. This may be a more plausible way to go than relying on recipes.</p><p>When doing processing in batch mode on a cluster, there&#39;s usually no need to render the plots on screen. There exists such a backend for this purpose:</p><pre><code class="language-none">using PyPlot
PyPlot.matplotlib.use(&quot;Agg&quot;)</code></pre><p>However, notice that currently Agg backend does not support draw_artist. For example, you cannot add an anchored text to your figure.</p><p>Unlike the user recipes in <code>Plots.jl</code>, using <code>PyPlot.jl</code> would require to have it as a dependency. (This might not be necessary for the upcoming Julia 1.6!)</p><h2 id="Makie"><a class="docs-heading-anchor" href="#Makie">Makie</a><a id="Makie-1"></a><a class="docs-heading-anchor-permalink" href="#Makie" title="Permalink"></a></h2><p><a href="https://jkrumbiegel.github.io/MakieLayout.jl/dev/">MakieLayout</a> is a nice extension built on top of Makie to create publication quality figures and interactive plots. It basically includes all the funcationalities I want, so definitely worth a try.</p><h2 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h2><p>Several places where macros can be used:</p><ul><li>Create a subarray with a name symbol</li><li>Reduce wrapper code duplicates</li></ul><h2 id="Streamline"><a class="docs-heading-anchor" href="#Streamline">Streamline</a><a id="Streamline-1"></a><a class="docs-heading-anchor-permalink" href="#Streamline" title="Permalink"></a></h2><p>The built-in streamline function of Matplotlib/MATLAB is not proper for scientifically visualizing field information. The solution is to trace field lines with ODEs and plot the line series, similar to what has been done by <a href="https://github.com/spacepy/spacepy/blob/master/spacepy/pybats/trace2d.py">Spacepy</a>.</p><h2 id="GUI"><a class="docs-heading-anchor" href="#GUI">GUI</a><a id="GUI-1"></a><a class="docs-heading-anchor-permalink" href="#GUI" title="Permalink"></a></h2><p>As for the GUI development, GTK seems to be an ideal candidate. However, the <a href="https://github.com/JuliaGraphics/Gtk.jl">GTK interface in Julia</a> lacks full support for the toolkit, which makes it a little bit hard to use. I have only played with it for half a day. You can design the appearance of your window interactively, and save your in an HTML-like file.</p><p>Makie is actually good at this, with the underlying OpenGL support.</p><p>At this point GUI is not necessarily needed, if it does not speed up my own workflow.</p><h2 id="Todo-List"><a class="docs-heading-anchor" href="#Todo-List">Todo List</a><a id="Todo-List-1"></a><a class="docs-heading-anchor-permalink" href="#Todo-List" title="Permalink"></a></h2><ul><li>[x] Fixed colorbar control through Matplotlib</li><li>[x] Test suite for checking validity</li><li>[x] Cuts from 3D data visualization besides contour</li><li>[x] Field tracer 2D in Julia</li><li>[x] Derived variable support</li><li>[x] General postprocessing script for concatenating and converting files.</li><li>[x] Direct wrapper over Matplotlib functions to get seamless API</li><li>[x] Replace np.meshgrid with list comprehension</li><li>[x] Magnetic field line plots from simulation</li><li>[x] Particle phase space distribution plots</li><li>[ ] Add <a href="https://github.com/henry2004y/FieldTracer.jl">FieldTracer.jl</a> and <a href="https://github.com/henry2004y/TestParticle.jl">TestParticle.jl</a> to dependencies and create tests</li><li>[ ] Find a substitution of triangulation in Julia</li><li>[ ] Allow dot syntax to get dictionary contents (Base.convert?)</li><li>[ ] Macros for quickly looking at data (GUI is the ideal solution!)</li><li>[ ] Port to Makie</li><li>[ ] Animation</li><li>[ ] Make more separate small packages instead of one giant collection</li><li>[ ] Full coverage of tests</li></ul><h3 id="Learning-from-yt"><a class="docs-heading-anchor" href="#Learning-from-yt">Learning from yt</a><a id="Learning-from-yt-1"></a><a class="docs-heading-anchor-permalink" href="#Learning-from-yt" title="Permalink"></a></h3><p>The yt Project in Python is a much more mature postprocessing package than mine. That&#39;s a good place to learn.</p><ul><li><p>Off-axis slices: very similar to ParaView and other 3D visualization tools provide, make a 2D cut at any direction. This requires a robust interpolation scheme.</p></li><li><p>Projection: it is like an integral form of a quantity in a certain direction, and can be weighted or unweighted. It is not a necessary feature, as one can easily implement this once he or she knows how to do make off-axis slices.</p></li><li><p>Same interface for both structured and unstructure data: this is important for a larger user base.</p></li><li><p>Mesh plotting: they provide a method for adding mesh on top of plots. I haven&#39;t had a good implementation of this yet.</p></li><li><p>Center: it would be good to give the option of choosing the center of plots.</p></li><li><p>Units: they build a unit system using dictionary themselves. I don&#39;t want to reinvent the wheel, so I will just keep an eye on <code>Unitful.jl</code> and yt. What is inherited from IDL in <code>Batsrus.jl</code> needs rewritten.</p></li><li><p>Property control: I don&#39;t like the way yt handles figure properties like colorbar, axes, etc. Matplotlib already teaches you how to set these things, and yet again in yt they wrap everything with names they come up with. This is a more of a burden instead of benefit. They do certain things right like <code>set_cmap</code>, but not all of them. The section <code>Further Customization via Matplotlib</code> is all I want to see. Using popular libraries generally means that new comers won&#39;t take long to get used to the interfaces, and developers can have a eaiser time developing new features.</p></li><li><p>Log scale: symlog for data containing both positive and negative data, and switch to linear scale for small values.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Functions</a><a class="docs-footer-nextpage" href="../text/">Text Data Processing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 March 2021 09:12">Tuesday 16 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
